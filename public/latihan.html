<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Latihan Final - Alokasi Memori</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="./css/style.css">

  <style>
    /* main card */
    .card-quiz {
      width: 80%;
      max-width: 1100px;
      margin: 36px auto;
      padding: 28px;
      border-radius: 16px;
      background: rgba(46,48,55,0.78);
      color: #fff;
    }

    .top-row { display:flex; justify-content:space-between; gap:12px; align-items:center; flex-wrap:wrap; }

    .question-area { margin-top:18px; }

    /* MCQ options */
    .option-btn {
      display:block;
      text-align:left;
      width:100%;
      margin:8px 0;
      padding:12px 14px;
      border-radius:10px;
      background: rgba(59,59,71,0.7);
      color:#fff;
      border:1px solid rgba(255,255,255,0.04);
      cursor:pointer;
    }
    .option-btn:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.25); }
    .option-btn.selected { outline: 2px solid rgba(200,200,255,0.12); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }

    /* explanation */
    .explain {
      padding:12px 14px;
      border-radius:10px;
      margin-top:12px;
      font-size:0.95rem;
      line-height:1.35;
    }
    .explain.correct { background: rgba(56,141,90,0.14); border:1px solid rgba(56,141,90,0.25); color:#dff7e6; }
    .explain.wrong { background: rgba(182,58,58,0.12); border:1px solid rgba(182,58,58,0.22); color:#ffe6e6; }

    /* drag & drop */
    .tables-wrap {
      display:flex;
      gap:24px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .left-area { width:62%; min-width:320px; }
    .right-area { width:34%; min-width:240px; background: rgba(36,36,42,0.45); padding:12px; border-radius:10px; }
    .partition-table, .process-table { width:100%; border-collapse:collapse; }
    .partition-table th, .partition-table td, .process-table td { border:1px solid rgba(200,200,210,0.08); padding:8px; text-align:center; color:#fff; }
    .process-slot { min-height:46px; vertical-align:middle; }
    .draggable-process { margin:8px 0; padding:8px 10px; border-radius:10px; background:#2f6f8a; cursor:grab; color:#fff; }
    .drop-hover { outline:2px dashed rgba(200,230,255,0.5); }

    /* small controls */
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .btn-small { padding:8px 12px; border-radius:8px; background:#52616B; color:#d0d0d0; border:none; }

    /* progress */
    .progress-text { font-weight:600; }

    /* next button style */
    #nextBtn { background:#52616B; color:#d0d0d0; border:none; padding:10px 16px; border-radius:8px; }
    #nextBtn:disabled { opacity:0.5; }

    @media (max-width:900px){
      .left-area, .right-area { width:100%; }
      .tables-wrap { gap:12px; }
    }
  </style>
</head>
<body>
  <div id="navbar-container"></div>

  <div class="card-quiz">
    <div class="top-row">
      <div>
        <h2 style="margin:0">Latihan Interaktif: Alokasi Memori</h2>
        <div class="small-muted">7 soal pilihan ganda + 3 soal drag & drop</div>
      </div>
      <div style="text-align:right">
        <div class="progress-text" id="progressText">Soal 1 dari 10</div>
      </div>
    </div>

    <div id="quizRoot" class="question-area"></div>

    <div class="mt-3 d-flex justify-content-end gap-2">
      <button id="nextBtn" disabled>Soal Selanjutnya →</button>
    </div>
  </div>

  <!-- scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
  <script src="./templates/template.js"></script>

  <script>
    // ====== Data MCQ (7 soal) ======
    const mcqQuestions = [
      {
        type:'mcq',
        question: "Manakah pernyataan yang tepat mengenai algoritma First-Fit pada alokasi memori?",
        options: [
          "Memilih partisi dengan ukuran terkecil yang masih memadai untuk proses.",
          "Memilih partisi pertama yang cukup besar untuk menampung proses.",
          "Memilih partisi terbesar yang tersedia untuk proses.",
          "Selalu membagi partisi menjadi blok yang lebih kecil sebelum alokasi."
        ],
        answer: 1,
        explain: "Pada algoritma First-Fit, proses dialokasikan pada partisi pertama (dari awal daftar) yang memiliki ukuran cukup untuk menampung proses tersebut."
      },
      {
        type:'mcq',
        question: "Apa yang dimaksud fragmentasi eksternal?",
        options: [
          "Ruang kosong kecil yang tersebar di antara blok-blok yang digunakan sehingga menghambat alokasi proses besar.",
          "Ruang kosong yang berada di dalam blok yang sudah dialokasikan.",
          "Kehilangan data saat proses berpindah antar partisi.",
          "Kegagalan sistem operasi dalam mengalokasikan memori karena virtual memory penuh."
        ],
        answer: 0,
        explain: "Fragmentasi eksternal adalah kondisi di mana total ruang kosong cukup tetapi tersebar di beberapa bagian sehingga tidak ada bagian tunggal yang cukup besar untuk menampung proses besar."
      },
      {
        type:'mcq',
        question: "Apa tujuan utama algoritma Best-Fit?",
        options: [
          "Mengurangi fragmentasi internal dengan memilih partisi yang paling kecil namun cukup.",
          "Mempercepat proses alokasi dengan memilih partisi pertama.",
          "Mengalokasikan proses ke partisi terakhir saja.",
          "Memastikan setiap partisi terisi minimal satu proses."
        ],
        answer: 0,
        explain: "Best-Fit memilih partisi dengan ukuran terkecil yang masih cukup untuk proses, bertujuan mengurangi sisa ruang (fragmentasi internal) pada partisi tersebut."
      },
      {
        type:'mcq',
        question: "Dalam Worst-Fit, partisi yang dipilih biasanya adalah:",
        options: [
          "Partisi pertama yang cukup besar.",
          "Partisi dengan ukuran tepat sama dengan proses.",
          "Partisi terbesar yang tersedia.",
          "Partisi terkecil yang masih muat."
        ],
        answer: 2,
        explain: "Worst-Fit memilih partisi terbesar yang tersedia untuk mengalokasikan proses, dengan harapan menyisakan partisi cukup besar untuk proses lain."
      },
      {
        type:'mcq',
        question: "Jika sebuah proses tidak muat di partisi manapun, sistem biasanya akan:",
        options: [
          "Menempatkannya ke partisi terkecil yang ada.",
          "Membatalkan proses tersebut atau menunggu pembebasan memori (gagal alokasi).",
          "Membagi proses menjadi beberapa bagian dan menempatkannya di beberapa partisi.",
          "Secara otomatis menambah ukuran semua partisi."
        ],
        answer: 1,
        explain: "Jika tidak ada partisi yang cukup besar, alokasi akan gagal (proses tidak dialokasikan) hingga ada pembebasan memori atau kebijakan lain diterapkan."
      },
      {
        type:'mcq',
        question: "Apa kelemahan umum First-Fit dibanding Best-Fit?",
        options: [
          "First-Fit cenderung lebih lambat daripada Best-Fit.",
          "First-Fit menghasilkan lebih banyak fragmentasi internal di bagian awal daftar.",
          "First-Fit membutuhkan pengurutan partisi sebelum alokasi.",
          "First-Fit selalu menggunakan partisi terkecil."
        ],
        answer: 1,
        explain: "First-Fit dapat meninggalkan banyak sisa kecil pada partisi awal karena selalu memilih partisi pertama yang cukup, sehingga berpotensi meningkatkan fragmentasi pada bagian awal daftar."
      },
      {
        type:'mcq',
        question: "Dalam konteks alokasi memori, istilah 'hole' merujuk ke:",
        options: [
          "Proses yang sedang dieksekusi.",
          "Partisi yang sedang dipakai oleh proses.",
          "Ruang memori kosong (free space) antara blok yang dialokasikan.",
          "Tabel alokasi memori di sistem operasi."
        ],
        answer: 2,
        explain: "Hole adalah istilah yang digunakan untuk menunjukkan area memori kosong yang tersedia untuk alokasi proses."
      }
    ];

    // ====== Drag questions: 3 soal (First-Fit, Best-Fit, Worst-Fit)
    function makeMatchingDragQuestion(algo) {
      // generate n partitions (3-5), then create processes that fit each partition (so full fill)
      const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
      const n = randInt(3,5);
      const partitions = [];
      for (let i=0;i<n;i++){
        // choose partition size between 120..500
        partitions.push(randInt(120,500));
      }
      // create processes P1..Pn where size is <= partition size (slightly smaller)
      const processes = partitions.map((ps,i)=>{
        // make process size between (ps - 60) and ps (but at least 50)
        const low = Math.max(40, ps - 60);
        const size = Math.min(ps, Math.max(low, Math.floor(ps * (0.7 + Math.random()*0.25))));
        return { name: 'P'+(i+1), size: size };
      });
      return { type:'drag', algo: algo, partitions, processes };
    }

    const dragQuestions = [
      makeMatchingDragQuestion('First-Fit'),
      makeMatchingDragQuestion('Best-Fit'),
      makeMatchingDragQuestion('Worst-Fit')
    ];

    const allQuestions = [...mcqQuestions, ...dragQuestions];
    let index = 0;
    const total = allQuestions.length;

    // state
    const userAnswers = new Array(total).fill(null);

    // DOM refs
    const root = document.getElementById('quizRoot');
    const progressText = document.getElementById('progressText');
    const nextBtn = document.getElementById('nextBtn');

    // render current
    function renderCurrent() {
      root.innerHTML = '';
      progressText.textContent = `Soal ${index+1} dari ${total}`;
      const q = allQuestions[index];
      if (q.type === 'mcq') renderMCQ(q);
      else renderDrag(q);

      // next disabled until answered
      nextBtn.disabled = true;
      // if already answered earlier, enable next and show stored feedback
      if (userAnswers[index] !== null) {
        // for mcq the answer rendering will re-show; for drag, renderDrag restores if stored
        nextBtn.disabled = false;
      }
    }

    // ----- MCQ renderer -----
    function renderMCQ(q) {
      const container = document.createElement('div');
      container.innerHTML = `<h4>Soal ${index+1}:</h4><div style="margin-top:8px;font-weight:600;">${q.question}</div>`;
      const opts = document.createElement('div');
      opts.style.marginTop = '12px';

      q.options.forEach((opt,i)=>{
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'option-btn';
        btn.textContent = opt;
        btn.dataset.idx = i;
        btn.addEventListener('click', () => {
          // mark selection
          opts.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          userAnswers[index] = i;
          // show explanation
          showMCQExplain(q, i, container);
          // enable next
          nextBtn.disabled = false;
        });
        opts.appendChild(btn);
      });

      container.appendChild(opts);
      // placeholder for explanation
      const explainWrap = document.createElement('div');
      explainWrap.id = 'explainWrap';
      container.appendChild(explainWrap);

      root.appendChild(container);

      // if user had answered before, restore selection and explanation
      if (userAnswers[index] !== null) {
        const chosenIdx = userAnswers[index];
        const chosenBtn = opts.querySelector(`[data-idx="${chosenIdx}"]`);
        if (chosenBtn) chosenBtn.classList.add('selected');
        showMCQExplain(q, chosenIdx, container);
        nextBtn.disabled = false;
      }
    }

    function showMCQExplain(q, selectedIdx, container) {
      const correctIdx = q.answer;
      const isCorrect = selectedIdx === correctIdx;
      const wrap = container.querySelector('#explainWrap');
      wrap.innerHTML = '';
      const div = document.createElement('div');
      div.className = 'explain ' + (isCorrect ? 'correct' : 'wrong');
      const title = isCorrect ? '<strong>Jawaban benar.</strong>' : '<strong>Jawaban salah.</strong>';
      div.innerHTML = title + `<div style="margin-top:8px;">${q.explain}</div>`;
      wrap.appendChild(div);
    }

    // ----- Drag renderer -----
    function renderDrag(q) {
      const wrapper = document.createElement('div');
      wrapper.innerHTML = `<h4>Soal ${index+1} — Drag & Drop (${q.algo})</h4>
        <div class="small-muted" style="margin-top:6px;">Seret proses dari kanan ke kolom Process. Daftar proses berurutan P1, P2, ...</div>`;

      const tw = document.createElement('div');
      tw.className = 'tables-wrap';

      const left = document.createElement('div'); left.className='left-area';
      const right = document.createElement('div'); right.className='right-area';

      // partition table
      const pTitle = document.createElement('div'); pTitle.className='small-muted mb-1'; pTitle.textContent = 'Partisi';
      const pTable = document.createElement('table'); pTable.className='partition-table';
      pTable.innerHTML = '<thead><tr><th>Nama</th><th>Ukuran (KB)</th><th>Process</th></tr></thead><tbody></tbody>';
      const pBody = pTable.querySelector('tbody');

      // right pool
      const poolTitle = document.createElement('div'); poolTitle.className='small-muted mb-2'; poolTitle.textContent='Daftar Proses (urut ke bawah)';
      const pool = document.createElement('div'); pool.id='procPool';

      left.appendChild(pTitle); left.appendChild(pTable);
      right.appendChild(poolTitle); right.appendChild(pool);
      tw.appendChild(left); tw.appendChild(right);
      wrapper.appendChild(tw);

      // feedback element
      const feedback = document.createElement('div');
      feedback.style.marginTop = '12px';
      wrapper.appendChild(feedback);

      root.appendChild(wrapper);

      // Setup partitions and processes.
      // Here we ensure processes fit partitions (one-to-one)
      const PARTS = q.partitions.slice();
      const PROCS = q.processes.map(p=>({...p}));

      // create rows with drop area (single row per partition)
      PARTS.forEach((size,i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>Part${i+1}</td><td>${size}</td><td class="process-slot" id="slot-${i}" data-slot="${i}"></td>`;
        pBody.appendChild(tr);
      });

      // create processes pool vertically in order P1..Pn (no shuffle)
      PROCS.forEach(proc=>{
        const el = document.createElement('div');
        el.className = 'draggable-process';
        el.draggable = true;
        el.dataset.proc = proc.name;
        el.textContent = `${proc.name} (${proc.size} KB)`;
        el.addEventListener('dragstart', e=> e.dataTransfer.setData('text/plain', proc.name));
        pool.appendChild(el);
      });

      // attach drop handlers; when last slot filled -> auto-evaluate
      const totalSlots = PARTS.length;
      function onDropHandler(ev) {
        ev.preventDefault();
        const td = ev.currentTarget;
        td.classList.remove('drop-hover');
        const procName = ev.dataTransfer.getData('text/plain');
        if (!procName) return;
        // if slot already has proc, return it to pool
        if (td.dataset.proc) {
          addToPool(td.dataset.proc);
        }
        // remove proc element from pool (if exists)
        const el = pool.querySelector(`[data-proc="${procName}"]`);
        if (el) el.remove();
        td.textContent = procName;
        td.dataset.proc = procName;
        // check if all filled
        const filled = Array.from(document.querySelectorAll('.process-slot')).every(s => s.dataset.proc);
        if (filled) {
          // auto-evaluate
          evaluateDragAnswer();
        }
      }

      function addToPool(name) {
        if (pool.querySelector(`[data-proc="${name}"]`)) return;
        const procObj = PROCS.find(p=>p.name===name);
        if (!procObj) return;
        const el = document.createElement('div');
        el.className = 'draggable-process';
        el.draggable = true;
        el.dataset.proc = procObj.name;
        el.textContent = `${procObj.name} (${procObj.size} KB)`;
        el.addEventListener('dragstart', e=> e.dataTransfer.setData('text/plain', procObj.name));
        pool.appendChild(el);
      }

      // attach events to slots
      for (let i=0;i<totalSlots;i++){
        const slot = document.getElementById(`slot-${i}`);
        slot.addEventListener('dragover', e=> e.preventDefault());
        slot.addEventListener('dragenter', ()=> slot.classList.add('drop-hover'));
        slot.addEventListener('dragleave', ()=> slot.classList.remove('drop-hover'));
        slot.addEventListener('drop', onDropHandler);
        // allow double-click to return to pool
        slot.addEventListener('dblclick', ()=>{
          if (slot.dataset.proc) {
            addToPool(slot.dataset.proc);
            slot.textContent = '';
            delete slot.dataset.proc;
          }
        });
      }

      // compute expected mapping based on algorithm
      function computeExpected(parts, procs, algo) {
        const assign = {}; const used = new Array(parts.length).fill(false);
        if (algo === 'First-Fit') {
          for (const pr of procs) {
            for (let i=0;i<parts.length;i++){
              if (!used[i] && parts[i] >= pr.size) { assign[i] = pr.name; used[i]=true; break; }
            }
          }
        } else if (algo === 'Best-Fit') {
          for (const pr of procs) {
            let best=-1, bestRem=Infinity;
            for (let i=0;i<parts.length;i++){
              if (!used[i] && parts[i] >= pr.size) {
                const rem = parts[i]-pr.size;
                if (rem < bestRem) { bestRem = rem; best=i; }
              }
            }
            if (best !== -1) { assign[best] = pr.name; used[best]=true; }
          }
        } else { // Worst-Fit
          for (const pr of procs) {
            let worst=-1, worstRem=-1;
            for (let i=0;i<parts.length;i++){
              if (!used[i] && parts[i] >= pr.size) {
                const rem = parts[i]-pr.size;
                if (rem > worstRem) { worstRem = rem; worst=i; }
              }
            }
            if (worst !== -1) { assign[worst] = pr.name; used[worst]=true; }
          }
        }
        return assign;
      }

      function evaluateDragAnswer() {
        // clear previous hints
        pBody.querySelectorAll('.process-slot').forEach(s => { s.classList.remove('correct','wrong'); const old=s.querySelector('.expected-hint'); if(old) old.remove(); });

        const expected = computeExpected(PARTS, PROCS, q.algo);
        let correctCount = 0;
        for (let i=0;i<totalSlots;i++){
          const slot = document.getElementById(`slot-${i}`);
          const assigned = slot.dataset.proc || null;
          const expectedProc = expected[i] || null;
          if ((expectedProc && assigned === expectedProc) || (!expectedProc && !assigned)) {
            correctCount++;
            slot.classList.add('correct');
          } else {
            slot.classList.add('wrong');
            const hint = document.createElement('div');
            hint.className = 'expected-hint';
            hint.textContent = `→ seharusnya: ${expectedProc || '-'}`;
            slot.appendChild(hint);
          }
        }
        const pct = Math.round((correctCount / totalSlots) * 100);
        const explainDiv = document.createElement('div');
        explainDiv.className = 'explain ' + (pct === 100 ? 'correct' : 'wrong');
        explainDiv.innerHTML = `<strong>Hasil: ${pct}% benar (${correctCount}/${totalSlots}).</strong>
          <div style="margin-top:8px;">Pembahasan formal: Algoritma ${q.algo} menempatkan proses berdasarkan kriteria ${q.algo}. Perhatikan pemilihan partisi yang sesuai untuk tiap proses.</div>`;
        feedback.innerHTML = '';
        feedback.appendChild(explainDiv);

        // store assignment
        const map = {};
        for (let i=0;i<totalSlots;i++){
          const slot = document.getElementById(`slot-${i}`);
          map[i] = slot.dataset.proc || null;
        }
        userAnswers[index] = map;

        // enable next
        nextBtn.disabled = false;
      }

      // If user previously answered -> restore
      if (userAnswers[index]) {
        const prev = userAnswers[index];
        for (let i=0;i<totalSlots;i++){
          const val = prev[i];
          if (val) {
            const slot = document.getElementById(`slot-${i}`);
            slot.textContent = val;
            slot.dataset.proc = val;
            // remove from pool if still exists
            const rem = pool.querySelector(`[data-proc="${val}"]`); if (rem) rem.remove();
          }
        }
        // auto-evaluate to show marks and feedback
        evaluateDragAnswer();
      }
    }

    // next button behavior
    nextBtn.addEventListener('click', ()=>{
      if (index < total-1) {
        index++;
        renderCurrent();
      } else {
        showSummary();
      }
    });

    // summary
    function showSummary() {
      // count mcq correct
      let mcqCorrect = 0;
      for (let i=0;i<mcqQuestions.length;i++){
        const ans = userAnswers[i];
        if (ans !== null && ans === mcqQuestions[i].answer) mcqCorrect++;
      }
      // drag correctness: compare mappings to expected
      let dragCorrectSlots = 0, dragTotalSlots = 0;
      for (let k=0;k<dragQuestions.length;k++){
        const qIdx = mcqQuestions.length + k;
        const q = allQuestions[qIdx];
        const ua = userAnswers[qIdx];
        if (!ua) continue;
        const expected = (function(){ // compute expected mapping
          const parts = q.partitions.slice();
          const procs = q.processes.map(p=>({...p}));
          const assign = {}; const used = new Array(parts.length).fill(false);
          if (q.algo === 'First-Fit') {
            for (const pr of procs){ for (let i=0;i<parts.length;i++){ if (!used[i] && parts[i] >= pr.size){ assign[i]=pr.name; used[i]=true; break; } } }
          } else if (q.algo === 'Best-Fit') {
            for (const pr of procs){ let best=-1,bestRem=Infinity; for (let i=0;i<parts.length;i++){ if (!used[i] && parts[i] >= pr.size){ const rem = parts[i]-pr.size; if (rem < bestRem){bestRem=rem; best=i;} } } if (best !== -1){assign[best]=pr.name; used[best]=true;} }
          } else {
            for (const pr of procs){ let worst=-1,worstRem=-1; for (let i=0;i<parts.length;i++){ if (!used[i] && parts[i] >= pr.size){ const rem = parts[i]-pr.size; if (rem > worstRem){worstRem=rem; worst=i;} } } if (worst !== -1){assign[worst]=pr.name; used[worst]=true;} }
          }
          return assign;
        })();
        for (const sIdx in ua) {
          dragTotalSlots++;
          const assigned = ua[sIdx];
          const expectedProc = expected[sIdx] || null;
          if ((expectedProc && assigned === expectedProc) || (!expectedProc && !assigned)) dragCorrectSlots++;
        }
      }

      const totalCorrect = mcqCorrect + dragCorrectSlots;
      const totalPossible = mcqQuestions.length + dragTotalSlots;
      const percent = totalPossible ? Math.round((totalCorrect/totalPossible)*100) : 0;

      root.innerHTML = `<h3>Ringkasan Hasil</h3>
        <p class="small-muted">MCQ benar: ${mcqCorrect} / ${mcqQuestions.length}</p>
        <p class="small-muted">Slot drag benar: ${dragCorrectSlots} / ${dragTotalSlots}</p>
        <div style="margin-top:12px;" class="explain ${percent===100?'correct':'wrong'}">Skor keseluruhan: ${percent}%</div>
        <div style="margin-top:12px;"><button id="restartBtn" class="btn btn-sm btn-pink">Ulangi Latihan</button></div>`;

      document.getElementById('restartBtn').addEventListener('click', ()=> {
        // reset
        index = 0;
        for (let i=0;i<userAnswers.length;i++) userAnswers[i] = null;
        // regenerate new drag questions so sizes change on restart
        for (let k=0;k<3;k++){
          allQuestions[mcqQuestions.length + k] = makeMatchingDragQuestion(['First-Fit','Best-Fit','Worst-Fit'][k]);
        }
        renderCurrent();
      });
      nextBtn.disabled = true;
    }

    // initial render
    renderCurrent();
  </script>
</body>
</html>
