<!DOCTYPE html>
<html lang="id">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Materi Memory Allocation</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="./css/materi.css">
  <style>
    section {
      display: none;
    }

    section.active {
      display: block;
      animation: fadeIn 0.6s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .nav-pills .nav-link {
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }

    .nav-pills .nav-link.active {
      background-color: #0d6efd;
      color: white !important;
    }

    .nav-pills .nav-link:hover {
      transform: scale(1.05);
    }
  </style>
</head>

<body>
  <!-- Tempat navbar akan dimuat -->
  <div id="navbar-container"></div>

  <main class="container py-4">
    <h1 class="text-center mb-4 fw-bold text-primary">Materi Memory Allocation</h1>

    <!-- ðŸ”¹ Navigasi Sub-Page -->
    <nav class="nav nav-pills justify-content-center mb-4 flex-wrap">
      <button class="nav-link active" onclick="showPage('pendahuluan', event)">Pendahuluan</button>
      <button class="nav-link" onclick="showPage('jenis', event)">Jenis</button>
      <button class="nav-link" onclick="showPage('algoritma', event)">Algoritma</button>
      <button class="nav-link" onclick="showPage('fragmentasi', event)">Fragmentasi</button>
      <button class="nav-link" onclick="showPage('contoh', event)">Contoh</button>
    </nav>

    <!-- Pendahuluan -->
   <section class="materi-section">
  <h2>Pengertian dan Fungsi Manajemen Memori</h2>
  <p>
    <strong>Manajemen Memori</strong> merupakan salah satu komponen terpenting dalam sistem operasi yang berfungsi untuk 
    mengatur, mengalokasikan, dan memantau penggunaan <em>memori utama</em> (RAM) oleh berbagai proses yang berjalan secara bersamaan. 
    Tugas ini sangat krusial karena menentukan seberapa efisien dan stabil sebuah sistem dapat beroperasi.
  </p>

  <p>
    Tanpa manajemen memori yang baik, sistem operasi akan kesulitan mengatur proses yang membutuhkan ruang memori, 
    menyebabkan <em>crash</em>, lambatnya kinerja, bahkan hilangnya data akibat benturan antar proses. 
    Oleh karena itu, sistem operasi modern menggunakan berbagai strategi manajemen memori untuk menjamin keamanan, 
    efisiensi, dan keandalan sistem secara keseluruhan.
  </p>

  <h3>Tujuan Utama Manajemen Memori</h3>
  <ul>
    <li>
      <strong>1. Efisiensi:</strong> 
      Memastikan penggunaan RAM dilakukan secara optimal agar tidak ada ruang yang terbuang. 
      Sistem operasi membagi memori menjadi blok-blok tertentu (partisi) sehingga proses yang membutuhkan ruang kecil 
      tidak harus memesan memori besar. Ini juga mengurangi fragmentasi dan membantu meningkatkan performa sistem.
    </li>
    <li>
      <strong>2. Proteksi:</strong> 
      Menjaga agar proses satu tidak dapat mengakses area memori milik proses lain secara ilegal. 
      Proteksi ini penting untuk mencegah kesalahan fatal, pencurian data, serta menjaga stabilitas sistem. 
      Biasanya diterapkan melalui mekanisme seperti <em>memory boundaries</em> dan <em>access control</em>.
    </li>
    <li>
      <strong>3. Fleksibilitas:</strong> 
      Memungkinkan proses berpindah ke memori sekunder (<em>swap space</em>) saat kapasitas utama penuh, 
      dan kembali lagi ke RAM ketika dibutuhkan. Teknik ini dikenal dengan istilah <em>swapping</em>, 
      yang memastikan proses tetap dapat berjalan meskipun kapasitas RAM terbatas.
    </li>
    <li>
      <strong>4. Kinerja:</strong> 
      Menjaga agar CPU selalu memiliki proses untuk dijalankan. Dengan manajemen memori yang efisien, 
      sistem operasi dapat melakukan <em>multitasking</em> dengan lancar tanpa membuat sistem melambat. 
      Proses yang aktif dapat terus berpindah dari RAM ke penyimpanan sementara sesuai prioritas.
    </li>
  </ul>

  <h3>Konsep-Konsep Penting dalam Manajemen Memori Modern</h3>
  <p>
    Dalam sistem operasi modern, manajemen memori telah berkembang dengan mengadopsi berbagai mekanisme canggih 
    untuk meningkatkan fleksibilitas, keamanan, dan efisiensi. Beberapa konsep penting di antaranya:
  </p>
  <ul>
    <li>
      <strong>Virtual Memory:</strong> 
      Konsep ini memungkinkan sistem menjalankan program yang lebih besar dari kapasitas fisik RAM dengan memanfaatkan 
      ruang penyimpanan sekunder (seperti hard disk atau SSD) sebagai perluasan memori. 
      Dengan virtual memory, pengguna dapat membuka banyak aplikasi sekaligus tanpa kehabisan ruang RAM.
    </li>
    <li>
      <strong>Paging:</strong> 
      Teknik ini membagi memori menjadi unit kecil bernama <em>page</em> dan menyimpan data proses dalam bentuk halaman. 
      Hal ini membuat alokasi dan pengelolaan memori menjadi lebih fleksibel dan mengurangi fragmentasi eksternal.
    </li>
    <li>
      <strong>Segmentation:</strong> 
      Pendekatan ini membagi memori berdasarkan unit logis seperti fungsi, variabel, atau modul program. 
      Segmentation memudahkan pengelolaan memori pada tingkat yang lebih konseptual dan meningkatkan keamanan program.
    </li>
  </ul>

  <p>
    Kesimpulannya, manajemen memori adalah tulang punggung efisiensi sistem operasi. 
    Dengan mekanisme seperti virtual memory, paging, dan segmentation, sistem dapat bekerja secara stabil, 
    mendukung multitasking, serta menjaga keamanan data di setiap proses yang berjalan. 
    Pemahaman tentang manajemen memori sangat penting bagi siapa pun yang mempelajari konsep dasar sistem operasi.
  </p>
</section>


   <section id="jenis" class="mb-5">
  <h2>Jenis Memory Allocation</h2>
  <p>
    <b>Memory allocation</b> adalah proses menentukan bagian memori mana yang akan digunakan oleh suatu proses.
    Terdapat dua pendekatan utama: <b>Static Allocation</b> dan <b>Dynamic Allocation</b>.
  </p>

  <h3>1. Static Allocation (Fixed Partitioning)</h3>
  <p>
    Pada metode ini, memori utama dibagi menjadi beberapa partisi berukuran tetap sebelum program dijalankan.
    Setiap partisi hanya dapat menampung satu proses, sehingga jika ukuran proses lebih kecil dari partisi,
    akan ada ruang kosong yang tidak terpakai.
  </p>
  <ul>
    <li><b>Kelebihan:</b> Implementasi mudah dan cocok untuk sistem batch atau sistem kecil.</li>
    <li><b>Kekurangan:</b> Dapat menyebabkan <b>internal fragmentation</b> karena sisa ruang tidak bisa digunakan oleh proses lain.</li>
  </ul>

  <h3>2. Dynamic Allocation (Variable Partitioning)</h3>
  <p>
    Berbeda dengan metode statis, ukuran partisi dibuat secara dinamis berdasarkan kebutuhan proses yang datang.
    Ketika proses selesai, ruang tersebut akan dikembalikan dan dapat digunakan oleh proses lain.
  </p>
  <ul>
    <li><b>Kelebihan:</b> Lebih fleksibel dan efisien dalam penggunaan ruang memori.</li>
    <li><b>Kekurangan:</b> Dapat menyebabkan <b>external fragmentation</b> karena ruang kosong terpecah-pecah.</li>
  </ul>

  <div class="alert alert-info mt-4">
    ðŸ’¡ <b>Catatan:</b> Sistem operasi modern sudah jarang menggunakan partisi tetap.
    Sebaliknya, mereka menerapkan konsep <b>paging</b> dan <b>segmentation</b> yang memungkinkan
    proses disimpan dalam blok-blok kecil dan tidak harus bersebelahan secara fisik di memori.
  </div>
</section>


    <!-- Algoritma -->
    <section id="algoritma" class="mb-5">
      <h2> Algoritma Pengalokasian Memori</h2>
      <p>
        Dalam <b>variable partitioning</b>, sistem operasi harus mencari blok memori kosong
        (<i>hole</i>) yang cukup besar untuk proses baru. Berikut tiga algoritma yang umum digunakan:
      </p>

      <h3> First-Fit</h3>
      <p>
        Proses ditempatkan pada blok pertama yang ukurannya cukup besar.
        Metode ini cepat karena tidak menelusuri seluruh memori.
      </p>

      <h3> Best-Fit</h3>
      <p>
        Mencari blok terkecil yang masih cukup besar untuk menampung proses.
        Tujuannya adalah meminimalkan sisa ruang kosong (fragmentasi eksternal).
      </p>

      <h3> Worst-Fit</h3>
      <p>
        Memilih blok terbesar untuk menampung proses, agar menyisakan ruang kosong yang besar
        dan dapat digunakan untuk proses berikutnya.
      </p>

      <div class="table-responsive mt-4">
        <table class="table table-bordered text-center">
          <thead class="table-light">
            <tr>
              <th>Algoritma</th>
              <th>Kelebihan</th>
              <th>Kekurangan</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>First-Fit</b></td>
              <td>Cepat, karena berhenti di blok pertama yang cocok.</td>
              <td>Bisa menyebabkan fragmentasi di bagian awal memori.</td>
            </tr>
            <tr>
              <td><b>Best-Fit</b></td>
              <td>Penggunaan memori lebih efisien.</td>
              <td>Lambat karena harus menelusuri semua blok kosong.</td>
            </tr>
            <tr>
              <td><b>Worst-Fit</b></td>
              <td>Mempertahankan blok besar untuk proses mendatang.</td>
              <td>Kurang efisien karena bisa menghasilkan fragmentasi besar.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Fragmentasi -->
    <section id="fragmentasi" class="mb-5">
      <h2> Fragmentasi Memori</h2>
      <p>
        Fragmentasi adalah kondisi di mana memori tidak dapat digunakan secara optimal
        karena ruang kosong tersebar atau tidak sesuai ukuran proses.
      </p>

      <div class="table-responsive">
        <table class="table table-bordered align-middle text-center">
          <thead class="table-light">
            <tr>
              <th>Jenis</th>
              <th>Deskripsi</th>
              <th>Penyebab</th>
              <th>Solusi</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>Internal</b></td>
              <td>Terjadi saat blok memori yang dialokasikan lebih besar dari kebutuhan proses.</td>
              <td>Fixed Partitioning</td>
              <td>Gunakan partisi dinamis atau teknik paging.</td>
            </tr>
            <tr>
              <td><b>External</b></td>
              <td>Ruang kosong tersebar di antara blok yang terisi sehingga tidak cukup besar untuk proses baru.</td>
              <td>Variable Partitioning</td>
              <td>Lakukan <b>compaction</b> atau gunakan <b>non-contiguous allocation</b>.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p>
        Dalam sistem modern, fragmentasi eksternal banyak diatasi dengan
        teknik <b>paging</b> yang membagi memori menjadi blok-blok kecil (frame) berukuran tetap,
        sehingga proses tidak perlu menempati ruang bersebelahan.
      </p>
    </section>

    <!-- Contoh Kasus -->
    <section id="contoh" class="mb-5">
      <h2> Contoh Kasus dan Analisis</h2>
      <p>
        Diketahui blok memori kosong: <code>100 KB, 500 KB, 200 KB, 300 KB, 600 KB</code><br>
        Proses yang datang: <code>212 KB, 417 KB, 112 KB, 426 KB</code>
      </p>

      <div class="alert alert-secondary">
        <b>Soal:</b> Tentukan hasil alokasi dengan algoritma <b>First-Fit</b>, <b>Best-Fit</b>, dan <b>Worst-Fit</b>.
      </div>

      <h3>Hasil Alokasi</h3>
      <ul>
        <li><b>First-Fit:</b> Menempatkan proses pada blok pertama yang cukup besar.</li>
        <li><b>Best-Fit:</b> Menempatkan proses pada blok dengan sisa terkecil.</li>
        <li><b>Worst-Fit:</b> Menempatkan proses pada blok terbesar yang tersedia.</li>
      </ul>

      <p class="mt-3">
        Dengan latihan ini, kamu dapat memahami bagaimana strategi berbeda menghasilkan efisiensi berbeda.
        Implementasi algoritma ini akan kamu temui pada simulasi di halaman <b>Simulasi</b>.
      </p>
    </section>

  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
  <script src="js/template.js"></script>
  <script src="js/materi.js"></script>
</body>
</html>
