<!DOCTYPE html>
<html lang="id">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Materi Memory Allocation</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="./css/style.css">
</head>

<body>
  <!-- Tempat navbar akan dimuat -->
  <div id="navbar-container"></div>

  <main class="container py-4">

    <!-- Pendahuluan -->
    <section id="pendahuluan" class="mb-5">
      <h2>1. Pengertian dan Tujuan</h2>
      <p>
        <b>Manajemen Memori</b> adalah komponen sistem operasi yang memastikan sumber daya memori utama
        dimanfaatkan secara efektif dan efisien untuk mendukung proses yang berjalan.
        Semua proses harus disimpan di memori utama (RAM) sebelum dapat dieksekusi oleh CPU.
        Karena kapasitas memori terbatas, sistem operasi bertugas mengatur peletakan proses agar CPU selalu
        memiliki proses untuk dijalankan tanpa membuang sumber daya.
      </p>
      <p>
        Tujuan utama manajemen memori adalah:
      </p>
      <ul>
        <li><b>Memory Allocation & Deallocation</b>: Mengalokasikan memori untuk proses saat diperlukan dan
          melepaskannya saat sudah tidak digunakan.</li>
        <li><b>Protection & Isolation</b>: Mencegah proses saling mengganggu ruang memori satu sama lain.</li>
        <li><b>Mapping & Address Translation</b>: Menerjemahkan alamat logis (virtual) ke alamat fisik.</li>
        <li><b>Swapping</b>: Menukar proses antara RAM dan penyimpanan sekunder agar memori selalu tersedia.</li>
      </ul>
    </section>

    <!-- Jenis Alokasi -->
    <section id="jenis" class="mb-5">
      <h2>2. Jenis Memory Allocation</h2>
      <p>
        Memory allocation adalah proses penentuan bagian memori mana yang akan digunakan oleh suatu proses.
        Secara umum dibagi menjadi dua tipe utama: <b>static (fixed)</b> dan <b>dynamic (variable)</b>.
      </p>

      <h3>a. Static (Fixed Partitioning)</h3>
      <p>
        Pada metode ini, memori utama dibagi menjadi beberapa partisi berukuran tetap ketika sistem dijalankan.
        Setiap partisi hanya dapat menampung satu proses. Jumlah proses yang dapat berjalan bersamaan
        dibatasi oleh jumlah partisi.
      </p>
      <p><b>Kelebihan:</b> sederhana dan mudah dikelola.</p>
      <p><b>Kekurangan:</b> dapat terjadi <b>internal fragmentation</b>,
        yaitu pemborosan memori saat blok yang dialokasikan lebih besar dari kebutuhan proses.</p>

      <h3>b. Dynamic (Variable Partitioning)</h3>
      <p>
        Pada metode ini, ukuran partisi memori menyesuaikan ukuran proses yang akan masuk. Proses baru
        mendapat blok memori dengan ukuran sesuai kebutuhannya, sehingga penggunaan memori lebih efisien.
      </p>
      <p><b>Kelebihan:</b> lebih fleksibel dan memanfaatkan ruang memori lebih optimal.</p>
      <p><b>Kekurangan:</b> dapat terjadi <b>external fragmentation</b>,
        yaitu ruang kosong kecil yang tersebar di antara blok terisi.</p>
    </section>

    <!-- Algoritma -->
    <section id="algoritma" class="mb-5">
      <h2>3. Algoritma Contiguous Memory Allocation</h2>
      <p>
        Dalam <b>variable partitioning</b>, sistem operasi harus mencari blok memori kosong
        (hole) yang cukup besar untuk proses baru. Tiga algoritma umum digunakan:
      </p>
      <ul>
        <li>
          <b>First-Fit:</b> proses ditempatkan di blok kosong pertama yang cukup besar.
          <ul>
            <li><b>Kelebihan:</b> cepat karena berhenti pada blok pertama yang cocok.</li>
            <li><b>Kekurangan:</b> dapat menyebabkan external fragmentation.</li>
          </ul>
        </li>
        <li>
          <b>Best-Fit:</b> memilih blok terkecil yang masih cukup besar untuk menampung proses.
          <ul>
            <li><b>Kelebihan:</b> meminimalkan fragmentasi eksternal, penggunaan memori lebih efisien.</li>
            <li><b>Kekurangan:</b> lebih lambat karena harus mencari seluruh daftar blok kosong.</li>
          </ul>
        </li>
        <li>
          <b>Worst-Fit:</b> memilih blok terbesar yang tersedia agar menyisakan ruang kosong besar
          untuk proses lain di masa mendatang.
          <ul>
            <li><b>Kelebihan:</b> bisa bermanfaat jika proses besar datang kemudian.</li>
            <li><b>Kekurangan:</b> tidak efisien karena blok besar cepat habis.</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- Fragmentasi -->
    <section id="fragmentasi" class="mb-5">
      <h2>4. Fragmentasi Memori</h2>
      <p>
        Fragmentasi terjadi ketika ruang memori tidak dapat digunakan secara optimal karena pembagian blok
        yang tidak efisien.
      </p>
      <table class="table table-bordered">
        <thead class="table-light">
          <tr>
            <th>Jenis Fragmentasi</th>
            <th>Penjelasan</th>
            <th>Penyebab</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b>Internal Fragmentation</b></td>
            <td>Terjadi ketika blok memori yang dialokasikan lebih besar dari kebutuhan proses, menyisakan
              ruang tidak terpakai di dalam blok tersebut.</td>
            <td>Fixed Partitioning</td>
          </tr>
          <tr>
            <td><b>External Fragmentation</b></td>
            <td>Terjadi ketika ruang kosong tersebar di antara blok-blok yang terisi, sehingga total ruang cukup
              tetapi tidak bersebelahan untuk proses baru.</td>
            <td>Variable Partitioning</td>
          </tr>
        </tbody>
      </table>
      <p>
        Solusi umum untuk mengurangi fragmentasi eksternal adalah <b>compaction</b>,
        yaitu menggabungkan ruang kosong menjadi satu blok besar yang berdekatan.
      </p>
    </section>

    <!-- Contoh Kasus -->
    <section id="contoh" class="mb-5">
      <h2>5. Contoh Kasus</h2>
      <p>
        Diberikan partisi memori: <code>100 KB, 500 KB, 200 KB, 300 KB, 600 KB</code>.<br>
        Proses yang masuk: <code>212 KB, 417 KB, 112 KB, 426 KB</code>.
      </p>
      <p><b>Tugas:</b> Tentukan hasil alokasi dengan algoritma First-Fit, Best-Fit, dan Worst-Fit.</p>
      <ul>
        <li>
          <b>First-Fit:</b> proses ditempatkan di blok kosong pertama yang cukup besar.
        </li>
        <li>
          <b>Best-Fit:</b> memilih blok dengan sisa paling kecil setelah alokasi.
        </li>
        <li>
          <b>Worst-Fit:</b> memilih blok terbesar untuk setiap proses.
        </li>
      </ul>
      <p>
        Setelah alokasi selesai, bandingkan sisa memori kosong untuk menentukan efisiensi masing-masing algoritma.
      </p>
    </section>

    <!-- Kesimpulan -->
    <section id="kesimpulan" class="mb-5">
      <h2>6. Kesimpulan</h2>
      <ul>
        <li><b>Tujuan utama:</b> mengatur penggunaan memori agar efisien, cepat, dan aman.</li>
        <li><b>Masalah umum:</b> fragmentasi internal & eksternal.</li>
        <li><b>Solusi modern:</b> teknik <b>paging</b> dan <b>segmentation</b> memungkinkan proses ditempatkan
          tidak bersebelahan untuk memaksimalkan penggunaan memori.</li>
        <li><b>Efisiensi sistem:</b> bergantung pada algoritma alokasi dan mekanisme manajemen memori yang digunakan.</li>
      </ul>
    </section>

    <!-- Referensi -->
    <section id="referensi" class="mb-5">
      <h2>7. Referensi</h2>
      <ul>
        <li><b>Week 7</b> – Manajemen Memori (6 Oktober 2025). Materi: Main memory, logical & physical address,
          static vs dynamic loading, contiguous & non-contiguous allocation.</li>
        <li><b>Week 9</b> – Contiguous Memory Allocation (17 Oktober 2025). Materi: Variable partitioning,
          algoritma First-Fit, Best-Fit, Worst-Fit.</li>
      </ul>
    </section>

  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
  <script src="../assets/js/template.js"></script>
  <script src="js/script.js"></script>
</body>
</html>
